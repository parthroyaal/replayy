
<!-- bybit
  -->
<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TradingView Advanced Chart with CSV Data Demo</title>
  <link href="./tailwind.min.css" rel="stylesheet">

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .chart {
      width: 100%;
      height: 100vh; /* Make the chart occupy the full viewport height */
      /* Adjusted for nav bar height */
      border: 1px solid #ddd;
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if the content is too tall */
    }

    #formSection {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #chartSection {
      display: none;
      height: 100%;
      overflow: hidden;
      overflow-y: auto; /* Allow the chart section to scroll vertically if needed */

      flex: 1;
      /* Allow the chart section to take up available space */
      display: flex;
      /* Enable flexbox layout for the chart section */
      flex-direction: column;
      /* Stack elements vertically */
    }



    #chart_container {
      flex: 1;
      /* Allow chart to take up remaining space */
      border: 1px solid #ddd;
      box-sizing: border-box;
      overflow: visible;
    }

    .floating-widget {
      position: fixed;
      top: 60px;
      /* Adjust for nav bar */
      width: 400px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      display: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      max-height: 80vh;
      overflow-y: auto;
    }

    /* mogno */
    #price-widget {
      left: 10px;
    }

    #log-widget {
      left: 10px;
    }

    .close-widget {
      float: left;
      cursor: pointer;
      font-size: 20px;
    }

    #priceTableContainer,
    #tradeLogContainer {
      display: block;
      /* Make them visible */
      width: 100%;
      /* Take full width */
    }

    /* Navigation Tab Styles */
    nav {
      background-color: #f0f0f0;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    .tab-link {
      display: inline-block;
      padding: 5px 10px;
      margin-right: 10px;
      text-decoration: none;
      color: #333;
      border: 1px solid transparent;
      border-radius: 3px;
      cursor: pointer;
    }

    .tab-link.active {
      background-color: #ddd;
      border-color: #ccc;
      font-weight: bold;
    }

    #initialLoadDateInput {
      margin-top: 10px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
  </style>
</head>

<body class="m-0 p-0">



     
<!-- Mwidget -->
<div class="flex items-center space-x-2 bg-white p-2 rounded-md shadow">
    <span class="text-sm font-medium mr-2">Market Replay</span>
    <button id="playButton" class="p-1 rounded-md hover:bg-gray-200">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-circle"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>
    </button>
    <button id="skipButton" class="p-1 rounded-md hover:bg-gray-200">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-skip-forward"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/></svg>
    </button>
    <select id="playbackSpeed" class="text-sm font-medium bg-transparent border-none focus:ring-0">
        <option value="0.1">0.1x</option>
        <option value="0.3">0.3x</option>
        <option value="1" selected>1x</option>
        <option value="3">3x</option>
    </select>
    <button id="sellButton" class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600">Sell</button>
    <span id="cumulativeProfitDisplay" class="text-sm font-medium"></span>
    <button id="buyButton" class="px-3 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600">Buy</button>
    <button id="flattenButton" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">Flatten</button>
    <button class="p-1 rounded-md hover:bg-gray-200">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
    </button>
  </div>
  
  
  
  
  <!-- Mwidget -->

  <div id="formSection" class="p-4">
    <h1 class="text-2xl font-bold mb-4">Select CSV File for Chart</h1>
    <form id="csvForm" class="w-full max-w-lg">
      <div class="mb-4">
        <label for="csvFile" class="block text-sm font-medium text-gray-700">CSV Data:</label>
        <input type="file" id="csvFile" name="csvFile" accept=".csv"
          class="mt-1 block w-full text-sm text-gray-500
                      file:mr-4 file:py-2 file:px-4
                      file:rounded-full file:border-0
                      file:text-sm file:font-semibold
                      file:bg-blue-50 file:text-blue-700
                      hover:file:bg-blue-100">
      </div>
      <div class="mb-4">
        <label for="initialLoadDateInput" class="block text-sm font-medium text-gray-700">Initial Load Date (YYYY-MM-DD
          HH:MM:SS):</label>
        <input type="text" id="initialLoadDateInput" name="initialLoadDateInput"
          placeholder="e.g., 2023-12-31 10:00:00" class="mt-1 block w-full text-sm text-gray-500">
      </div>
    </form>
    <button id="loadChart" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Load Chart</button>
  </div>


  <div id="chartSection">
    <!-- nav -->

    <nav>
      <a href="#section1" class="tab-link active" data-timeframe="5S">Section 1: 5 sec</a>
      <a href="#section2" class="tab-link" data-timeframe="10S">Section 2: 10 sec</a>
      <a href="#section3" class="tab-link" data-timeframe="15S">Section 3: 15 sec</a>
      <a href="#section4" class="tab-link" data-timeframe="30S">Section 4: 30 sec</a>
      <a href="#section5" class="tab-link" data-timeframe="1">Section 5: 1 min</a>
      <a href="#section6" class="tab-link" data-timeframe="3">Section 6: 3 min</a>
      <a href="#section7" class="tab-link" data-timeframe="5">Section 7: 5 min</a>
      <a href="#section8" class="tab-link" data-timeframe="15">Section 8: 15 min</a>
      <a href="#section9" class="tab-link" data-timeframe="30">Section 9: 30 min</a>
    </nav>
    
    <div id="chart_container" class="chart"></div>
  </div>

  <div id="priceTableContainer">
    <div class="bg-white shadow-lg rounded-lg p-8 max-w-3xl w-full mb-8">
      <h1 class="text-2xl font-bold mb-6 text-center">Price Table</h1>
      <table id="priceTable" class="min-w-full border-collapse">
        <thead>
          <tr class="bg-gray-200">
            <th class="border px-4 py-2 text-left">Time</th>
            <th class="border px-4 py-2 text-left">CallPrice</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="border px-4 py-2" id="currentTime"></td>
            <td class="border px-4 py-2" id="callPrice"></td>
          </tr>
          <tr>
            <td class="border px-4 py-2"></td>
            <td class="border px-4 py-2">
              <!-- <button class="bg-green-500 text-white px-2 py-1 rounded hover:bg-green-400"
                onclick="buy('callPrice')">Buy</button>
              <button class="bg-red-500 text-white px-2 py-1 rounded hover:bg-red-400"
                onclick="sell('callPrice')">Sell</button> -->
              <div id="callLog" class="mt-2 text-sm text-gray-600"></div>
              <div id="callChange" class="text-sm text-gray-500">Change: 0%</div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div id="tradeLogContainer">
    <div class="bg-white shadow-lg rounded-lg p-8 max-w-3xl w-full">
      <h2 class="text-2xl font-bold mb-6 text-center">Trade Log</h2>
      <table id="tradeLogTable" class="min-w-full border-collapse">
        <thead>
          <tr class="bg-gray-200">
            <th class="border px-4 py-2 text-left">Trade No</th>
            <th class="border px-4 py-2 text-left">Entry Time</th>
            <th class="border px-4 py-2 text-left">Exit Time </th>
            <th class="border px-4 py-2 text-left">Entry Type</th>
            <th class="border px-4 py-2 text-left">Entry Price</th>
            <th class="border px-4 py-2 text-left">Exit Price</th>
            <th class="border px-4 py-2 text-left">Change %</th>
          </tr>
        </thead>
        <tbody id="tradeLogBody"></tbody>
      </table>
    </div>
  </div>

  <p class="mt-4 text-center text-gray-600">Press Ctrl+. to toggle the price widget. Press Ctrl+; to toggle the trade
    log widget. Press Ctrl+' to pause/resume streaming and updating.</p>

  <div id="price-widget" class="floating-widget">
    <span class="close-widget" onclick="toggleWidget('price-widget')">×</span>
    <h3 class="text-lg font-bold mb-2">Price Table</h3>
    <div id="price-widget-content"></div>
  </div>

  <div id="log-widget" class="floating-widget">
    <span class="close-widget" onclick="toggleWidget('log-widget')">×</span>
    <h3 class="text-lg font-bold mb-2">Trade Log</h3>
    <div id="log-widget-content"></div>
  </div>

  <script type="text/javascript" src="charting_library/charting_library.js"></script>
  <script>
       // ... your JavaScript code ...

    // Simulate Alt+. on page load
    window.onload = function() {
      document.dispatchEvent(new KeyboardEvent('keydown', {
        key: '.',
        altKey: true,
        code: 'Semicolon', // Correct code for Semicolon
        bubbles: true,
        cancelable: true
      }));
    };

    // ... your remaining JavaScript code ...
    const allBars = {
      leftTop: [],
      rightTop: [],
      leftBottom: [],
      rightBottom: []
    };

    let lastUpdateTime = 0;
    let isPaused = false;
    let priceUpdateInterval;


// mWidgetLogi

document.addEventListener('DOMContentLoaded', function() {
    const playButton = document.getElementById('playButton');
    const skipButton = document.getElementById('skipButton');
    const sellButton = document.getElementById('sellButton');
    const buyButton = document.getElementById('buyButton');
    const flattenButton = document.getElementById('flattenButton');
    const playbackSpeedSelect = document.getElementById('playbackSpeed');
    const cumulativeProfitDisplay = document.getElementById('cumulativeProfitDisplay');
    

    
// MONGO

    // Update the play button icon based on state
    function updatePlayButtonIcon() {
        const svg = playButton.querySelector('svg');
        if (isPaused) {
            svg.innerHTML = '<circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/>';
        } else {
            svg.innerHTML = '<circle cx="12" cy="12" r="10"/><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>';
        }
    }
    



// Play button handler
playButton.addEventListener('click', function() {
    isPaused = !isPaused;
    console.log("Streaming and updating paused:", isPaused);
    updatePlayButtonIcon();
    
    if (isPaused) {
        clearInterval(priceUpdateInterval);
    } else {
        // Simulate pressing Alt + "
        document.dispatchEvent(new KeyboardEvent('keydown', {
            key: '"',
            altKey: true,
            code: 'Quote',
            bubbles: true,
            cancelable: true
        }));
    }
});

    // Skip button handler
    skipButton.addEventListener('click', function() {
        console.log("Skipping to next bar");
        if (isPaused) {
            updatePrices();
        }
    });

    // Buy button handler
    buyButton.addEventListener('click', function() {
        if (!callTradeOpen) {
            const currentPrice = parseFloat(document.getElementById('callPrice').innerText);
            buy('callPrice');
            console.log("Buy executed at:", currentPrice);
        }
    });

    // Sell button handler
    sellButton.addEventListener('click', function() {
    if (!callTradeOpen) {
        const currentPrice = parseFloat(document.getElementById('callPrice').innerText);
        callEntryPrice = currentPrice;
        document.getElementById('callLog').innerText = `Sold Short at: $${currentPrice}`;
        callTradeOpen = true;
        const currentTime = document.getElementById('currentTime').innerText;
        addTradeLog('Short', currentPrice, currentTime); // Use 'Short' for sell entries
        console.log("Sell executed at:", currentPrice);
    }
});




// ... (existing code) ...

let cumulativeProfit = 0; 
let cumulativePercentageChange = 0;

// ... (inside the flattenButton event listener) ...

flattenButton.addEventListener('click', function() {
    if (callTradeOpen) {
        const currentPrice = parseFloat(document.getElementById('callPrice').innerText);
        sell('callPrice');
        console.log("Position flattened at:", currentPrice);

        // Get the percentage change from the last row in the Trade Log
        const lastRow = document.getElementById(`trade-${tradeCount}`);
        const tradeProfitPercentage = parseFloat(lastRow.cells[6].innerText.replace('%', '')); // Remove '%'

        cumulativeProfit += (currentPrice - callEntryPrice); 
        cumulativePercentageChange += parseFloat(tradeProfitPercentage); 

        // Update the display
        updateCumulativeProfitDisplay(tradeProfitPercentage, cumulativePercentageChange); 
    }
});


function updateCumulativeProfitDisplay(tradeProfitPercentage, cumulativePercentageChange) {
    cumulativeProfitDisplay.textContent = 
        `Profit:  
         (Trade Change: ${tradeProfitPercentage}%, Cumulative Change: ${cumulativePercentageChange.toFixed(2)}%)`;
}


 
    // Playback speed handler
    playbackSpeedSelect.addEventListener('change', function() {
        const speed = parseFloat(this.value);
        console.log('Playback speed changed to:', speed + 'x');
        // Implement speed change logic here
    });

    // Initialize the display
    updateCumulativeProfitDisplay();
    updatePlayButtonIcon();
});


// mongo fyers

function unixToMillis(unixTime) {
      return unixTime * 1000;
    }


  
  // // mongo bybit
  
        async function readCSV(file) {
        const text = await file.text();
        const rows = text.split('\n');
        const headers = rows[0].split(',');
  
        // Get column indices from headers
        const timeIndex = headers.indexOf('time');
        const openIndex = headers.indexOf('open');
        const highIndex = headers.indexOf('high');
        const lowIndex = headers.indexOf('low');
        const closeIndex = headers.indexOf('close');
        const volumeIndex = headers.indexOf('volume');
  
        let bars = [];
        for (let i = 1; i < rows.length; i++) {
            const row = rows[i].split(',');
            if (row.length === headers.length) { 
                bars.push({
                    time: new Date(row[timeIndex]).getTime() , // / 1000, // Convert time to Unix timestamp (seconds)
                    open: parseFloat(row[openIndex]),
                    high: parseFloat(row[highIndex]),
                    low: parseFloat(row[lowIndex]),
                    close: parseFloat(row[closeIndex]),
                    volume: parseInt(row[volumeIndex])
                });
            }
        }
        return bars;
        }
  
  


    const dataArrays = {
      '5S': [],
      '10S': [],
      '15S': [],
      '30S': [],
      '1': [],
      '3': [],
      '5': [],
      '15': [],
      '30': [],
      '60': [],
      '120': [],
      '240': [],
      '1D': [],
      '1W': [],
      '1M': []
    };

    let historicalData = [];
    // mongo
    function streamData(data, interval = 1000) {
      let index = 0;
      return {
        next() {
          return new Promise((resolve) => {
            if (index < data.length) {
              setTimeout(() => {
                resolve({ value: data[index++], done: false });
              }, interval);
            } else {
              resolve({ done: true });
            }
          });
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }

    function aggregateData(data, timeframe) {
      const aggregated = [];
      let currentBucket = null;
      const timeframeMs = getTimeframeMs(timeframe);

      for (let row of data) {
        const bucketTime = Math.floor(row.time / timeframeMs) * timeframeMs;

        if (!currentBucket || currentBucket.time !== bucketTime) {
          if (currentBucket) {
            aggregated.push(currentBucket);
          }
          currentBucket = {
            time: bucketTime,
            open: row.open,
            high: row.high,
            low: row.low,
            close: row.close,
            volume: row.volume
          };
        } else {
          currentBucket.high = Math.max(currentBucket.high, row.high);
          currentBucket.low = Math.min(currentBucket.low, row.low);
          currentBucket.close = row.close;
          currentBucket.volume += row.volume;
        }
      }

      if (currentBucket) {
        aggregated.push(currentBucket);
      }

      return aggregated;
    }

    function getTimeframeMs(timeframe) {
      const unit = timeframe.slice(-1);
      const value = parseInt(timeframe);
      switch (unit) {
        case 'S':
          return value * 1000;
        case 'D':
          return value * 24 * 60 * 60 * 1000;
        case 'W':
          return value * 7 * 24 * 60 * 60 * 1000;
        case 'M':
          return value * 30 * 24 * 60 * 60 * 1000;
        default:
          return value * 60 * 1000;
      }
    }

    function resampleData(data, timeframe) {
      const resampledData = [];
      let currentBar = null;
      const timeframeMs = getTimeframeMs(timeframe);

      for (const row of data) {
        const barTime = Math.floor(row.time / timeframeMs) * timeframeMs;

        if (!currentBar || currentBar.time !== barTime) {
          if (currentBar) {
            resampledData.push(currentBar);
          }
          currentBar = {
            time: barTime,
            open: row.open,
            high: row.high,
            low: row.low,
            close: row.close,
            volume: row.volume
          };
        } else {
          currentBar.high = Math.max(currentBar.high, row.high);
          currentBar.low = Math.min(currentBar.low, row.low);
          currentBar.close = row.close;
          currentBar.volume += row.volume;
        }
      }

      if (currentBar) {
        resampledData.push(currentBar);
      }

      return resampledData;
    }

    async function startStreaming(allData) {
      const combinedData = [...allData.leftTop, ...allData.rightTop, ...allData.leftBottom, ...allData.rightBottom]
        .sort((a, b) => a.time - b.time);

      // mongo
      const dataStream = streamData(combinedData);
      for await (const newData of dataStream) {
        if (isPaused) {
          await new Promise(resolve => {
            const resumeListener = () => {
              if (!isPaused) {
                resolve();
                document.removeEventListener('keydown', resumeListener);
              }
            }
            document.addEventListener('keydown', resumeListener);
          });
        }

        console.log("New data received:", new Date(newData.time), newData);

        dataArrays['5S'].push(newData);
        historicalData.push(newData);

        for (let timeframe in dataArrays) {
          dataArrays[timeframe] = resampleData(historicalData, timeframe);
        }

        notifySubscribers(newData);
      }
      console.log("Streaming completed");
    }

    const subscribers = new Map();

    function notifySubscribers(newData) {
      for (let [subscriberUID, handler] of subscribers) {
        const {
          resolution
        } = handler;

        if (resolution === '5S') {
          handler.callback(newData);
        } else {
          const resampledData = resampleData(historicalData, resolution);
          if (resampledData.length > 0) {
            handler.callback(resampledData[resampledData.length - 1]);
          }
        }
      }
      updatePriceWidget(newData);
    }

    const configurationData = {
      supported_resolutions: ["5S", "10S", "15S", "30S", "1", "3", "5", "15", "30", "60", "120", "240", "1D", "1W", "1M"],
      // Updated with new timeframes
      exchanges: [{
        value: 'Kraken',
        name: 'Kraken',
        desc: 'Kraken bitcoin exchange',
      }],
      symbols_types: [{
        name: 'crypto',
        value: 'crypto',
      }],
    };

    const Datafeed = {
      onReady: (callback) => {
        console.log('[onReady]: Method call');
        setTimeout(() => callback(configurationData));
      },

      searchSymbols: (userInput, exchange, symbolType, onResultReadyCallback) => {
        console.log('[searchSymbols]: Method call');
        onResultReadyCallback([]);
      },

      resolveSymbol: (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) => {
        console.log('[resolveSymbol]: Method call', symbolName);
        const symbolInfo = {
          name: symbolName,
          description: symbolName,
          type: 'crypto',
          session: '24x7',
          timezone: "Asia/Kolkata",
          width: "100%",
          height: "100%",
          minmov: 1,
          pricescale: 100,
          has_intraday: true,
          has_seconds: true,
          intraday_multipliers: ['1', '60'],
          seconds_multipliers: ["5", "10", "15", "30"], // Updated with new timeframes
          supported_resolutions: configurationData.supported_resolutions,
          volume_precision: 2,
          data_status: 'streaming',
          visible: true,
        };

        onSymbolResolvedCallback(symbolInfo);
      },

      getBars: (symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) => {
        const {
          from,
          to,
          firstDataRequest
        } = periodParams;
        console.log('[getBars]: Method call', symbolInfo, resolution, new Date(from * 1000), new Date(to * 1000));

        if (firstDataRequest) {
          const bars = dataArrays[resolution];
          console.log(`[getBars]: returned entire ${resolution} array (${bars.length} bar(s))`, bars);
          onHistoryCallback(bars, {
            noData: bars.length === 0
          });
        } else {
          const bars = dataArrays[resolution].filter(bar => {
            const barTime = bar.time / 1000;
            return barTime >= from && barTime < to;
          });
          console.log(`[getBars]: returned ${bars.length} bar(s)`, bars);
          onHistoryCallback(bars, {
            noData: bars.length === 0
          });
        }
      },

      subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) => {
        console.log('[subscribeBars]: Method call with subscriberUID:', subscriberUID);
        subscribers.set(subscriberUID, {
          symbolInfo,
          resolution,
          callback: onRealtimeCallback
        });
      },

      unsubscribeBars: (subscriberUID) => {
        console.log('[unsubscribeBars]: Method call with subscriberUID:', subscriberUID);
        subscribers.delete(subscriberUID);
      },
    };

    let currentSection = 1;
    let currentInterval = '5S';

    document.getElementById('loadChart').addEventListener('click', async function () {
      const csvFile = document.getElementById('csvFile').files[0];
      const initialLoadDateInput = document.getElementById('initialLoadDateInput').value;

      if (csvFile) {
        allBars.leftTop = await readCSV(csvFile);

        if (allBars.leftTop.length > 0) {
          // Filter data based on initialLoadDate
          if (initialLoadDateInput) {
            const initialLoadDate = new Date(initialLoadDateInput).getTime();
            historicalData = allBars.leftTop.filter(bar => bar.time < initialLoadDate);
            const streamingData = allBars.leftTop.filter(bar => bar.time >= initialLoadDate);
            allBars.leftTop = streamingData;
          } else {
            historicalData = []; // No initial data if date not provided
          }

          // Resample historical data for all timeframes
          for (let timeframe in dataArrays) {
            dataArrays[timeframe] = resampleData(historicalData, timeframe);
          }

          createChart(currentInterval);
          startStreaming(allBars);
        }
      }

      document.getElementById('formSection').style.display = 'none';
      document.getElementById('chartSection').style.display = 'block';
      document.getElementById('priceTableContainer').style.display = 'block';
      document.getElementById('tradeLogContainer').style.display = 'block';
      // mongo
      priceUpdateInterval = setInterval(updatePrices, 1000);
    });

    function createChart(interval) {
      removeExistingChart();
      if (allBars.leftTop.length > 0) {
        createChartInstance("chart_container", allBars.leftTop, "CSV Data", interval);
      }
    }

    function createChartInstance(containerId, data, symbolName, interval) {
      const widget = new TradingView.widget({
        layout: {
          bottomMargin: 0,
          time_scale: {
            visible: true,
            right_offset: 5,
          },
        },

        symbol: symbolName,
        interval: interval,
        fullscreen: false,
        timezone: "Asia/Kolkata",
        width: "100%",
        height: "100%",
        container: containerId,
        datafeed: Datafeed,
        enabled_features: ["dont_show_boolean_study_arguments", "seconds_resolution"],
        library_path: 'charting_library/',
        theme: 'Light',
        time_scale: {
          visible: true,
        }
      });

      // mongo

      widget.onChartReady(() => {
        // Add RSI
        widget.chart().createStudy('Relative Strength Index', false, false, {
          length: 14,
        });

        // Add MACD
        widget.chart().createStudy('MACD', false, false, {
          fast_length: 12,
          slow_length: 26,
          signal_length: 9,
        });

        // Add Moving Averages
        const studies = [
          { name: "Moving Average", inputs: { length: 12 }, id: "MA12", options: { "plot.linewidth": 3, "plot.color": "yellow" } },
          { name: "Moving Average", inputs: { length: 24 }, id: "MA24", options: { "plot.linewidth": 3, "plot.color": "red" } },
          { name: "Moving Average", inputs: { length: 50 }, id: "MA50", options: { "plot.linewidth": 3, "plot.color": "black" } },
          { name: "Moving Average", inputs: { length: 200 }, id: "MA200", options: { "plot.linewidth": 4, "plot.color": "blue" } }
        ];

        studies.forEach(study => {
          widget.chart().createStudy(study.name, false, false, study.inputs, study.options, { id: study.id });
        });


      });

      return widget;
    }


    function removeExistingChart() {
      const container = document.getElementById('chart_container');
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
    }

    // Function to open a specific section
    function openSection(index) {
      const tabLinks = document.querySelectorAll(".tab-link");
      tabLinks.forEach(link => link.classList.remove("active"));

      const targetLink = tabLinks[index - 1];
      if (targetLink) {
        targetLink.classList.add("active");
        currentSection = index;


        currentInterval = targetLink.getAttribute('data-timeframe');


        createChart(currentInterval);
      }
    }

    // Add click event listeners to the tabs
    const tabLinks = document.querySelectorAll(".tab-link");
    tabLinks.forEach(link => {
      link.addEventListener("click", function (event) {
        event.preventDefault();
        const targetId = this.getAttribute("href").substring(1);
        const targetContent = document.getElementById(targetId);
        if (targetContent) {
          openSection([...tabLinks].indexOf(link) + 1);
        }
      });
    });

    // Add keyboard shortcuts for Ctrl+1 to Ctrl+9
    document.addEventListener("keydown", function (event) {
      if (event.altKey && event.key >= '1' && event.key <= '9') {
        const sectionNumber = parseInt(event.key);
        if (sectionNumber >= 1 && sectionNumber <= 9) {
          openSection(sectionNumber);
        }
      }
    });


    let priceWidgetVisible = false;
    let logWidgetVisible = false;
    let callEntryPrice = null;
    let tradeCount = 0;
    let callTradeOpen = false; // Track if a call trade is open

    let currentFullscreenChart = null;
    const chartSequence = ['chart_container'];
    let activeTradeId = null;

    function toggleFullscreen(chartId) {
      const chartElement = document.getElementById(chartId);
      if (chartElement) {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          chartElement.requestFullscreen().catch(err => console.error('Error attempting to enter fullscreen mode:', err));
        }
      }
    }

    function toggleWidget(widgetId) {
      const widget = document.getElementById(widgetId);
      const content = document.getElementById(widgetId + '-content');
      const sourceTable = widgetId === 'price-widget' ? 'priceTable' : 'tradeLogTable';
      if (widgetId === 'price-widget') {
        priceWidgetVisible = !priceWidgetVisible;
      } else {
        logWidgetVisible = !logWidgetVisible;
      }
      if (widget.style.display === 'none' || widget.style.display === '') {
        content.innerHTML = document.getElementById(sourceTable).outerHTML;
        widget.style.display = 'block';
      } else {
        widget.style.display = 'none';
      }
    }


    // MONGOO
 


  // 0mongo
    document.addEventListener('keydown', function (event) {
      if (event.altKey && event.key === '.') {
        event.preventDefault();
        toggleWidget('price-widget');
      } else if (event.altKey && event.key === ';') {
        event.preventDefault();
        toggleWidget('log-widget');
      } 
      else if (event.altKey && event.key === "'") {
        event.preventDefault();
        isPaused = !isPaused;
        console.log("Streaming and updating paused:", isPaused);
        if (isPaused) {
          clearInterval(priceUpdateInterval); // Clear the interval when pausing
        } else {
          lastUpdateTime = Date.now();
          updatePrices(); // Immediately update prices when resuming
          priceUpdateInterval = setInterval(updatePrices, 1000); // Restart the interval
        }
      } else if (event.ctrlKey && event.key === 'b') { // Ctrl+B for Buy/Sell Call
        event.preventDefault();
        if (!callTradeOpen) {
          buy('callPrice');
        } else {
          sell('callPrice');
        }
      };
    });

    function updatePrices() {
        if (!isPaused) {
            // Find the closest bar to the current lastUpdateTime
            // const closestBar = findClosestBar(lastUpdateTime);
            let closestBar = null;

            if (closestBar) {
            // Update lastUpdateTime to the timestamp of the found bar
            lastUpdateTime = closestBar.time;
            // Update the price widget with the closest bar data
            updatePriceWidget(closestBar); 
            }

        if (priceWidgetVisible) {
          toggleWidget('price-widget');
          toggleWidget('price-widget');
        }
      }
    }


    function updatePriceWidget(barData) {
        const currentTime = new Date(barData.time).toLocaleTimeString();
        let callPrice = 0;

        if (allBars.leftTop.some(bar => bar.time === barData.time)) {
            callPrice = barData.close;
        }

        document.getElementById('currentTime').innerText = currentTime;
        document.getElementById('callPrice').innerText = callPrice.toFixed(2);
        updatePercentageChange(callPrice, 'callChange', callEntryPrice);


      if (priceWidgetVisible) {
        document.getElementById('price-widget-content').innerHTML = document.getElementById('priceTable').outerHTML;
      }
    }

  

    function updatePercentageChange(currentPrice, changeId, entryPrice) {
        if (entryPrice !== null) {
            // Get the entry type for the current trade
            const tradeRow = document.getElementById(`trade-${tradeCount}`);
            const entryType = tradeRow.cells[3].innerText;
            
            let percentChange;
            if (entryType === 'Call') {
            // Long position
            percentChange = ((currentPrice - entryPrice) / entryPrice * 100).toFixed(2);
            } else {
            // Short position
            percentChange = ((entryPrice - currentPrice) / entryPrice * 100).toFixed(2);
            }
            document.getElementById(changeId).innerText = `Change: ${percentChange}%`;
        } else {
            document.getElementById(changeId).innerText = `Change: 0%`;
        }
        }


        function buy(priceId) {
            const price = parseFloat(document.getElementById(priceId).innerText);
            const logId = priceId === 'callPrice' ? 'callLog' : null;

            if (priceId === 'callPrice' && !callTradeOpen) {
                callEntryPrice = price;
                const entryType = 'Call'; // For long positions
                document.getElementById(logId).innerText = `Bought ${entryType} at: $${price}`;
                callTradeOpen = true;
                const currentTime = document.getElementById('currentTime').innerText;
                addTradeLog(entryType, price, currentTime);
            }
            }

            function sell(priceId) {
                const price = parseFloat(document.getElementById(priceId).innerText);
                const logId = priceId === 'callPrice' ? 'callLog' : null;
                let entryPrice = priceId === 'callPrice' ? callEntryPrice : null;

                if (priceId === 'callPrice' && callTradeOpen) {
                    if (entryPrice !== null) {
                    // Check if this was a buy or sell entry
                    const tradeRow = document.getElementById(`trade-${tradeCount}`);
                    const entryType = tradeRow.cells[3].innerText; // Get entry type from trade log
                    
                    // Calculate percent change based on entry type
                    let percentChange;
                    if (entryType === 'Call') {
                        // Long position: profit when exit price > entry price
                        percentChange = ((price - entryPrice) / entryPrice * 100).toFixed(2);
                    } else {
                        // Short position: profit when exit price < entry price
                        percentChange = ((entryPrice - price) / entryPrice * 100).toFixed(2);
                    }
                    
                    document.getElementById(logId).innerText += ` | Sold at: $${price} | % Change: ${percentChange}%`;
                    updateTradeLog(priceId, price, percentChange);
                    callEntryPrice = null;
                    callTradeOpen = false;
                    }
                }
                }
                
// Also update the addTradeLog function to maintain consistency
function addTradeLog(entryType, entryPrice, currentTime) {
  tradeCount++;

  const newRow = document.createElement('tr');
  newRow.innerHTML = `
    <td class="border px-4 py-2">${tradeCount}</td>
    <td class="border px-4 py-2">${currentTime}</td> 
    <td class="border px-4 py-2">-</td>  <!-- Exit Time -->
    <td class="border px-4 py-2">${entryType}</td> 
    <td class="border px-4 py-2">$${entryPrice.toFixed(2)}</td>
    <td class="border px-4 py-2">-</td>  <!-- Exit Price -->
    <td class="border px-4 py-2">-</td>  <!-- Change % -->
  `;
  newRow.id = `trade-${tradeCount}`;
  document.getElementById('tradeLogBody').appendChild(newRow);
  
  if (logWidgetVisible) {
    toggleWidget('log-widget');
    toggleWidget('log-widget');
  }
}

    function updateTradeLog(exitType, exitPrice, percentChange) {
  const lastRow = document.getElementById(`trade-${tradeCount}`);
  if (lastRow) {
    // Get the current time
    const exitTime = document.getElementById('currentTime').innerText;

    // Update cells with correct column assignments
    lastRow.cells[2].innerText = exitTime;  // Exit Time
    lastRow.cells[5].innerText = `$${exitPrice.toFixed(2)}`; // Exit Price
    lastRow.cells[6].innerText = `${percentChange}%`;  // Change %
  }
  
  if (logWidgetVisible) {
    toggleWidget('log-widget');
    toggleWidget('log-widget');
  }
}

    function switchToNextChart() {
      let nextChartId;
      if (currentFullscreenChart) {
        const currentIndex = chartSequence.indexOf(currentFullscreenChart);
        const nextIndex = (currentIndex + 1) % chartSequence.length;
        nextChartId = chartSequence[nextIndex];
      } else {
        nextChartId = chartSequence[0];
      }

      if (document.fullscreenElement) {
        document.exitFullscreen().then(() => {
          setTimeout(() => toggleFullscreen(nextChartId), 100);
        });
      } else {
        toggleFullscreen(nextChartId);
      }
    }

    document.addEventListener('keydown', function (event) {
      if (event.ctrlKey) {
        switch (event.key) {
          case '1':
            toggleFullscreen('chart_container');
            break;
          case 'Tab':
            event.preventDefault();
            switchToNextChart();
            break;
        }
      } else if (event.key === 'Tab') {
        event.preventDefault();
        if (!document.fullscreenElement) {
          toggleFullscreen(chartSequence[0]);
        } else {
          switchToNextChart();
        }
      }
    });

    document.addEventListener('fullscreenchange', function () {
      if (!document.fullscreenElement) {
        currentFullscreenChart = null;
      }
    });
  </script>
</body>

</html>

<!-- 
2024-09-26 09:33:00
  -->